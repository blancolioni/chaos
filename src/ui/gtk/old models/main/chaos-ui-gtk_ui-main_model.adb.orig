with Ada.Text_IO;

with Ada.Containers.Doubly_Linked_Lists;
with Ada.Numerics;

with Glib;
with Glib.Main;

with Gdk.Event;
with Gdk.RGBA;
with Gdk.Window;

with Gtk.Enums;

with Gtk.Box;
with Gtk.Button;
with Gtk.Drawing_Area;
with Gtk.Text_Buffer;
with Gtk.Text_Iter;
with Gtk.Text_Mark;
with Gtk.Text_View;
with Gtk.Widget;

with Cairo;
with Cairo.Matrix;

with Chaos.Db.Actor;
with Chaos.Db.Creature;
with Chaos.Db.Party;

with Chaos.Creatures.Update;
with Chaos.Players;

with Chaos.World.Map;
with Chaos.World.Updates;

with Chaos.UI.Gtk_UI.Resources;
with Chaos.UI.Localisation;

package body Chaos.UI.Gtk_UI.Main_Model is

   use Glib;

   DX : constant array (Chaos.Db.Direction) of Glib.Gdouble :=
          (0.0, 1.0, 1.0, 1.0, 0.0, -1.0, -1.0, -1.0);
   DY : constant array (Chaos.Db.Direction) of Glib.Gdouble :=
          (-1.0, -1.0, 0.0, 1.0, 1.0, 1.0, 0.0, -1.0);

   --  View transform
   Translate_X : constant := 0.67;
   Translate_Y : constant := 0.33;
   Scale_X     : constant := 1.0;
   Scale_Y     : constant := 0.75;
   Rotate_X    : constant := 0.5;
   Rotate_Y    : constant := 0.0;

   type Point is
      record
         X, Y : Glib.Gdouble;
      end record;

   type Quadrangle is array (1 .. 4) of Point;

   package List_Of_Creatures is
     new Ada.Containers.Doubly_Linked_Lists
       (Chaos.Db.Creature_Reference, Chaos.Db."=");

   function Acts_Earlier
     (Left, Right : Chaos.Db.Creature_Reference)
      return Boolean;

   package Initiative_Sorting is
     new List_Of_Creatures.Generic_Sorting (Acts_Earlier);
   pragma Unreferenced (Initiative_Sorting);

   type Command_Button is
     new Gtk.Button.Gtk_Button_Record with
      record
         Command : Chaos.Players.Command_Type;
      end record;

   type Command_Button_Access is access all Command_Button'Class;

   function Create_Command_Button
     (Command : Chaos.Players.Command_Type)
      return Gtk.Button.Gtk_Button;

   procedure On_Command_Button_Click
     (Command_Button : access Gtk.Button.Gtk_Button_Record'Class);

   procedure Update_Command_Buttons;

   type Text_Buffer_Logger is
     new Root_Logger with
      record
         Buffer : Gtk.Text_Buffer.Gtk_Text_Buffer;
         View   : Gtk.Text_View.Gtk_Text_View;
      end record;

   overriding procedure Log
     (Logger : Text_Buffer_Logger;
      Actor  : String;
      Message : String);

   type Root_Main_Model is
     new Root_Gtk_Model with
      record
         Draw_Area              : Gtk.Drawing_Area.Gtk_Drawing_Area;
         Feedback_Text_View     : Gtk.Text_View.Gtk_Text_View;
         Tool_Button_Box        : Gtk.Box.Gtk_Box;
         Width, Height          : Glib.Gdouble;
         Ground_Surface         : Cairo.Cairo_Surface := Cairo.Null_Surface;
         Creature_Surface       : Cairo.Cairo_Surface := Cairo.Null_Surface;
         Feedback_Surface       : Cairo.Cairo_Surface := Cairo.Null_Surface;
         Interface_Surface      : Cairo.Cairo_Surface := Cairo.Null_Surface;
         Zoom                   : Positive := 32;
         Creature_List          : List_Of_Creatures.List;
         Party_List             : List_Of_Creatures.List;
         Centre                 : Chaos.World.World_Location;
         Left_X, Top_Y          : Chaos.World.World_Coordinate;
         Right_X, Bottom_Y      : Chaos.World.World_Coordinate;
         Squares_Across         : Chaos.World.World_Coordinate;
         Squares_Down           : Chaos.World.World_Coordinate;
         Selected_Square        : Chaos.World.World_Location;
         Hover_Square           : Chaos.World.World_Location;
         Selected_Player        : Chaos.Players.Player_Type;
         Acting_Creature        : List_Of_Creatures.Cursor :=
                                    List_Of_Creatures.No_Element;
         Walking_Creature       : Chaos.Db.Creature_Reference :=
                                    Chaos.Db.Null_Creature_Reference;
         Walking_Path_Index     : Natural;
         Walking_Path           : access Chaos.World.World_Path;
         Current_Command        : Chaos.Players.Command_Type;
         Timeout_Id             : Glib.Main.G_Source_Id;
      end record;

   overriding procedure On_Creature_Death
     (Model    : Root_Main_Model;
      Creature : Chaos.Db.Creature_Reference);

   overriding procedure Creature_Walk
     (Model    : in out Root_Main_Model;
      Creature : Chaos.Db.Creature_Reference;
      Path     : Chaos.World.World_Path);

   overriding procedure Active_Creature
     (Model : in out Root_Main_Model;
      Creature : Chaos.Db.Creature_Reference);

   overriding procedure Creature_End_Turn
     (Model    : in out Root_Main_Model;
      Creature : Chaos.Db.Creature_Reference);

   procedure Remove_Creature
     (Model : in out Root_Main_Model'Class;
      Creature : Chaos.Db.Creature.Creature_Type) with Unreferenced;

   type Main_Model_Access is access all Root_Main_Model'Class;

   Local_Main_Model : Main_Model_Access;

   procedure Create_Model;

   function On_Timeout return Boolean;

   function On_Screen
     (X, Y : Integer)
      return Boolean
   is (X in Integer (Local_Main_Model.Left_X)
       .. Integer (Local_Main_Model.Right_X)
       and then Y in Integer (Local_Main_Model.Top_Y)
       .. Integer (Local_Main_Model.Bottom_Y));

   function Get_Square_Boundary
     (World_X, World_Y : Chaos.World.World_Coordinate)
      return Quadrangle;

   function Get_Square_Top_Left
     (World_X, World_Y : Chaos.World.World_Coordinate)
      return Point;
   pragma Unreferenced (Get_Square_Top_Left);

   function Get_World_Square
     (P : Point)
      return Chaos.World.World_Location;

   function Get_Square_Centre
     (World_X, World_Y : Chaos.World.World_Coordinate)
      return Point;

   procedure Set_Square_Background
     (Cr               : Cairo.Cairo_Context;
      World_X, World_Y : Chaos.World.World_Coordinate);

   procedure Redraw;

   procedure Draw_Model;

   procedure Draw_Creatures;

   procedure Draw_Feedback;

   procedure Draw_Interface;

--     procedure Load_Creatures;

   function Configure_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Event : Gdk.Event.Gdk_Event_Configure)
      return Boolean;

   function Motion_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Event : Gdk.Event.Gdk_Event_Motion)
      return Boolean;

   function Button_Up_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Event : Gdk.Event.Gdk_Event_Button)
      return Boolean;

   function Paint_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Cr   : Cairo.Cairo_Context)
      return Boolean;

   function Scroll_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Event : Gdk.Event.Gdk_Event_Scroll)
      return Boolean;

   procedure Creature_Turn
     (Creature : Chaos.Db.Creature_Reference);
   pragma Unreferenced (Creature_Turn);

   procedure Show_Tool_Buttons;

   procedure Command_Feedback_Colour
     (Cr : Cairo.Cairo_Context;
      Command : Chaos.Players.Command_Type;
      Target  : Chaos.World.World_Location);

   ---------------------
   -- Active_Creature --
   ---------------------

   overriding procedure Active_Creature
     (Model : in out Root_Main_Model;
      Creature : Chaos.Db.Creature_Reference)
   is
      use List_Of_Creatures;
      Position : Cursor := Model.Creature_List.First;
      Initiative : Natural;
   begin
      if Model.Creature_List.Contains (Creature) then
         return;
      end if;

      Initiative := Chaos.Creatures.Initiative (Creature);
      if Initiative = 0 then
         Chaos.Creatures.Roll_Initiative (Creature);
         Initiative := Chaos.Creatures.Initiative (Creature);
      end if;

      while Has_Element (Position) loop
         exit when Chaos.Creatures.Initiative (Element (Position))
           < Initiative;
         Next (Position);
      end loop;

      if Has_Element (Position) then
         Model.Creature_List.Insert (Position, Creature);
      else
         Model.Creature_List.Append (Creature);
      end if;

      Draw_Creatures;

      Model.Draw_Area.Queue_Draw;

   end Active_Creature;

   ------------------
   -- Acts_Earlier --
   ------------------

   function Acts_Earlier
     (Left, Right : Chaos.Db.Creature_Reference)
      return Boolean
   is
      use type Chaos.Db.Creature_Reference;
   begin
      if Left = Right then
         return False;
      else
         declare
            Creature_1 : constant Chaos.Db.Creature.Creature_Type :=
                           Chaos.Db.Creature.Get (Left);
            Creature_2 : constant Chaos.Db.Creature.Creature_Type :=
                           Chaos.Db.Creature.Get (Left);
         begin
            return Creature_1.Initiative > Creature_2.Initiative;
         end;
      end if;
   end Acts_Earlier;

   -------------------------
   -- Button_Up_Draw_Area --
   -------------------------

   function Button_Up_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Event : Gdk.Event.Gdk_Event_Button)
      return Boolean
   is
      pragma Unreferenced (Self);
      use type Chaos.Players.Command_Type;
      Location : constant Chaos.World.World_Location :=
                   Get_World_Square ((Event.X, Event.Y));
   begin
      if Local_Main_Model.Current_Command /= null
        and then Local_Main_Model.Current_Command.Destination_OK (Location)
      then
         Local_Main_Model.Current_Command.Execute (Location);
      end if;
      Update_Command_Buttons;
      Redraw;
      Local_Main_Model.Draw_Area.Queue_Draw;
      return False;
   end Button_Up_Draw_Area;

   -----------------------------
   -- Command_Feedback_Colour --
   -----------------------------

   procedure Command_Feedback_Colour
     (Cr : Cairo.Cairo_Context;
      Command : Chaos.Players.Command_Type;
      Target  : Chaos.World.World_Location)
   is
   begin
      if Command.Is_Move then
         if Command.Destination_Long (Target) then
            Cairo.Set_Source_Rgb (Cr, 1.0, 1.0, 1.0);
         else
            Cairo.Set_Source_Rgb (Cr, 0.6, 0.8, 0.2);
         end if;
      elsif Command.Is_Attack then
         Cairo.Set_Source_Rgb (Cr, 1.0, 0.0, 0.0);
      else
         Cairo.Set_Source_Rgb (Cr, 1.0, 1.0, 1.0);
      end if;
   end Command_Feedback_Colour;

   -------------------------
   -- Configure_Draw_Area --
   -------------------------

   function Configure_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Event : Gdk.Event.Gdk_Event_Configure)
      return Boolean
   is
      use type Cairo.Cairo_Surface;
      pragma Unreferenced (Event);
      Width, Height : Glib.Gint;
   begin

      if Local_Main_Model.Ground_Surface /= Cairo.Null_Surface then
         Cairo.Surface_Destroy (Local_Main_Model.Ground_Surface);
         Cairo.Surface_Destroy (Local_Main_Model.Creature_Surface);
         Cairo.Surface_Destroy (Local_Main_Model.Feedback_Surface);
         Cairo.Surface_Destroy (Local_Main_Model.Interface_Surface);
      end if;

      Width := Self.Get_Allocated_Width;
      Height := Self.Get_Allocated_Height;

      Local_Main_Model.Width := Glib.Gdouble (Width);
      Local_Main_Model.Height := Glib.Gdouble (Height);

      Local_Main_Model.Ground_Surface :=
        Gdk.Window.Create_Similar_Surface
          (Self.Get_Window,
           Cairo.Cairo_Content_Color,
           Width * 2, Height * 2);

      Local_Main_Model.Creature_Surface :=
        Gdk.Window.Create_Similar_Surface
          (Self.Get_Window,
           Cairo.Cairo_Content_Color_Alpha,
           Width * 2, Height * 2);

      Local_Main_Model.Feedback_Surface :=
        Gdk.Window.Create_Similar_Surface
          (Self.Get_Window,
           Cairo.Cairo_Content_Color_Alpha,
           Width * 2, Height * 2);

      Local_Main_Model.Interface_Surface :=
        Gdk.Window.Create_Similar_Surface
          (Self.Get_Window,
           Cairo.Cairo_Content_Color_Alpha,
           Width, Height);

      Redraw;

      return True;

   end Configure_Draw_Area;

   ---------------------------
   -- Create_Command_Button --
   ---------------------------

   function Create_Command_Button
     (Command : Chaos.Players.Command_Type)
      return Gtk.Button.Gtk_Button
   is
--              Button : constant Gtk.Button.Gtk_Button :=
--                         Gtk.Button.Gtk_Button_New_With_Label
--                           (Chaos.UI.Localisation.Local_Capital_Text
--                              (Item.Tag & "-button"));
      Button : constant Command_Button_Access := new Command_Button;
   begin
      Button.Initialize
        (Chaos.UI.Localisation.Local_Capital_Text
           (Command.Tag));
      Button.Command := Command;
      Button.On_Clicked (On_Command_Button_Click'Access);
      return Gtk.Button.Gtk_Button (Button);
   end Create_Command_Button;

   ------------------
   -- Create_Model --
   ------------------

   procedure Create_Model is
      Top : constant Gtk.Widget.Gtk_Widget :=
              Gtk.Widget.Gtk_Widget
                (UI_Definition.Get_Object ("Main_Model"));
   begin
      Local_Main_Model := new Root_Main_Model;

      Local_Main_Model.Expand := True;
      Local_Main_Model.Draw_Area :=
        Gtk.Drawing_Area.Gtk_Drawing_Area
          (UI_Definition.Get_Object ("Main_Draw_Area"));
      Local_Main_Model.Feedback_Text_View :=
        Gtk.Text_View.Gtk_Text_View
          (UI_Definition.Get_Object ("Text_Feedback"));
      Local_Main_Model.Tool_Button_Box :=
        Gtk.Box.Gtk_Box
          (UI_Definition.Get_Object ("Tool_Buttons"));

      Local_Main_Model.Draw_Area.On_Configure_Event
        (Configure_Draw_Area'Access);
      Local_Main_Model.Draw_Area.On_Draw
        (Paint_Draw_Area'Access);
      Local_Main_Model.Draw_Area.On_Motion_Notify_Event
        (Motion_Draw_Area'Access);
      Local_Main_Model.Draw_Area.On_Button_Release_Event
        (Button_Up_Draw_Area'Access);
      Local_Main_Model.Draw_Area.On_Scroll_Event
        (Scroll_Draw_Area'Access);

      Local_Main_Model.Feedback_Text_View.Override_Background_Color
        (Gtk.Enums.Gtk_State_Flag_Normal,
         Gdk.RGBA.Black_RGBA);

      Local_Main_Model.Feedback_Text_View.Override_Color
        (Gtk.Enums.Gtk_State_Flag_Normal,
         Gdk.RGBA.White_RGBA);

      Local_Main_Model.Create_Model (Top);
   end Create_Model;

   -----------------------
   -- Creature_End_Turn --
   -----------------------

   overriding procedure Creature_End_Turn
     (Model    : in out Root_Main_Model;
      Creature : Chaos.Db.Creature_Reference)
   is
      pragma Unreferenced (Creature);
   begin
      List_Of_Creatures.Next (Model.Acting_Creature);
      Model.Selected_Player := null;
   end Creature_End_Turn;

   -------------------
   -- Creature_Turn --
   -------------------

   procedure Creature_Turn
     (Creature : Chaos.Db.Creature_Reference)
   is
      use type Chaos.Players.Player_Type;
      M : Main_Model_Access renames Local_Main_Model;
   begin
      M.Selected_Player := Chaos.Players.Get_Party_Member (Creature);
      if M.Selected_Player /= null then
         Show_Tool_Buttons;
      end if;
   end Creature_Turn;

   -------------------
   -- Creature_Walk --
   -------------------

   overriding procedure Creature_Walk
     (Model    : in out Root_Main_Model;
      Creature : Chaos.Db.Creature_Reference;
      Path     : Chaos.World.World_Path)
   is
   begin
      Model.Walking_Creature := Creature;
      Model.Walking_Path := new Chaos.World.World_Path'(Path);
      Model.Walking_Path_Index := 0;
   end Creature_Walk;

   --------------------
   -- Draw_Creatures --
   --------------------

   procedure Draw_Creatures is
      use Glib;
      M  : constant Main_Model_Access := Local_Main_Model;
      Cr : constant Cairo.Cairo_Context :=
             Cairo.Create (M.Creature_Surface);
   begin
      Cairo.Set_Source_Rgba (Cr, 0.0, 0.0, 0.0, 0.0);
      Cairo.Set_Operator (Cr, Cairo.Cairo_Operator_Source);
      Cairo.Paint (Cr);
      Cairo.Set_Operator (Cr, Cairo.Cairo_Operator_Over);

      for Ref of M.Creature_List loop
         declare
            Creature : constant Chaos.Db.Creature.Creature_Type :=
                         Chaos.Db.Creature.Get (Ref);
            Actor    : constant Chaos.Db.Actor.Actor_Type :=
                         Chaos.Db.Actor.Get (Creature.Actor);
            Tag      : constant String := Actor.Tag;
         begin
            if On_Screen (Creature.X, Creature.Y) then
               declare
                  use type Cairo.Cairo_Surface;
                  use Glib;
                  P  : constant Point :=
                         Get_Square_Centre
                           (Chaos.World.World_Coordinate (Creature.X),
                            Chaos.World.World_Coordinate (Creature.Y));
                  Image : constant Cairo.Cairo_Surface :=
                            Resources.Image_Surface (Tag);
                  Width : constant Natural :=
                            Resources.Image_Width (Tag);
                  Height : constant Natural :=
                            Resources.Image_Height (Tag);
               begin
                  if Width > 0 and then Height > 0 then
                     Cairo.Set_Source_Surface
                       (Cr, Image,
                        P.X - Gdouble (Width / 2),
                        P.Y - Gdouble (Height) + 7.0);
                     Cairo.Paint (Cr);
                  else
                     declare
                        R  : constant Gdouble := Gdouble (M.Zoom / 2) * 0.5;
                        Pi : constant := Ada.Numerics.Pi;
                     begin
                        Cairo.Set_Source_Rgb (Cr, 1.0, 0.0, 1.0);
                        Cairo.Arc
                          (Cr     => Cr,
                           Xc     => P.X,
                           Yc     => P.Y,
                           Radius => R,
                           Angle1 => 0.0,
                           Angle2 => 2.0 * Pi);
                        Cairo.Fill (Cr);
                        Cairo.Move_To (Cr, P.X, P.Y);
                        Cairo.Line_To (Cr,
                                       P.X + R * 1.5 * DX (Creature.Facing),
                                       P.Y + R * 1.5 * DY (Creature.Facing));
                        Cairo.Stroke (Cr);
                     end;
                  end if;
               end;
            end if;
         end;
      end loop;

      Cairo.Destroy (Cr);

   end Draw_Creatures;

   -------------------
   -- Draw_Feedback --
   -------------------

   procedure Draw_Feedback is
      use Glib;
      use Chaos.World;
      use Chaos.Players;
      M  : constant Main_Model_Access := Local_Main_Model;
      Cr : constant Cairo.Cairo_Context :=
             Cairo.Create (M.Feedback_Surface);
   begin
      Cairo.Set_Source_Rgba (Cr, 0.0, 0.0, 0.0, 0.0);
      Cairo.Set_Operator (Cr, Cairo.Cairo_Operator_Source);
      Cairo.Paint (Cr);
      Cairo.Set_Operator (Cr, Cairo.Cairo_Operator_Over);

      declare
         Quad : constant Quadrangle :=
                  Get_Square_Boundary
                    (M.Selected_Square.X, M.Selected_Square.Y);
      begin
         Cairo.Set_Source_Rgb (Cr, 1.0, 0.51, 0.0);
         Cairo.Move_To (Cr, Quad (Quad'Last).X, Quad (Quad'Last).Y);
         for P of Quad loop
            Cairo.Line_To (Cr, P.X, P.Y);
         end loop;
         Cairo.Stroke (Cr);
      end;

      if M.Selected_Square /= M.Hover_Square then
         declare
            Quad : constant Quadrangle :=
                     Get_Square_Boundary
                       (M.Hover_Square.X, M.Hover_Square.Y);
         begin
            Cairo.Set_Source_Rgb (Cr, 1.0, 1.0, 0.8);
            Cairo.Move_To (Cr, Quad (Quad'Last).X, Quad (Quad'Last).Y);
            for P of Quad loop
               Cairo.Line_To (Cr, P.X, P.Y);
            end loop;
            Cairo.Stroke (Cr);
         end;

         if M.Current_Command /= null then
            if M.Current_Command.Destination_OK (M.Hover_Square) then
               declare
                  Path : constant World_Path :=
                           M.Current_Command.Path_To (M.Hover_Square);
               begin
                  Cairo.Set_Line_Width (Cr, 2.0);
                  Cairo.Set_Line_Cap (Cr, Cairo.Cairo_Line_Cap_Round);
                  Command_Feedback_Colour
                    (Cr, M.Current_Command, M.Hover_Square);

                  for I in Path'Range loop
                     declare
                        P : constant Point :=
                              Get_Square_Centre (Path (I).X, Path (I).Y);
                     begin
                        if I = Path'First then
                           Cairo.Move_To (Cr, P.X, P.Y);
                        else
                           Cairo.Line_To (Cr, P.X, P.Y);
                        end if;
                     end;
                  end loop;
                  Cairo.Stroke (Cr);
               end;
            end if;
         end if;
      end if;

      Cairo.Destroy (Cr);
   end Draw_Feedback;

   --------------------
   -- Draw_Interface --
   --------------------

   procedure Draw_Interface is
      use Glib;
      M  : constant Main_Model_Access := Local_Main_Model;
      Cr : constant Cairo.Cairo_Context :=
             Cairo.Create (M.Interface_Surface);
   begin
      Cairo.Set_Source_Rgba (Cr, 0.0, 0.0, 0.0, 0.0);
      Cairo.Set_Operator (Cr, Cairo.Cairo_Operator_Source);
      Cairo.Paint (Cr);
      Cairo.Set_Operator (Cr, Cairo.Cairo_Operator_Over);

      for Party of Chaos.Db.Party.Select_By_Position loop
         declare
            X : constant Gdouble :=
                  Gdouble (M.Draw_Area.Get_Allocated_Width) - 64.0;
            Y : constant Gdouble :=
                  Gdouble (Party.Position - 1) * 64.0;
            Creature : constant Chaos.Db.Creature.Creature_Type :=
                         Chaos.Db.Creature.Get (Party.Creature);
            pragma Unreferenced (Creature);
            Image : constant Cairo.Cairo_Surface :=
                      Chaos.UI.Gtk_UI.Resources.Image_Surface
                           ("aramael-small");
         begin
            Cairo.Set_Source_Surface (Cr, Image, X, Y);
            Cairo.Paint (Cr);
         end;
      end loop;

      Cairo.Destroy (Cr);
   end Draw_Interface;

   ----------------
   -- Draw_Model --
   ----------------

   procedure Draw_Model is
      use Glib;
      M : constant Main_Model_Access := Local_Main_Model;
      Cr       : constant Cairo.Cairo_Context :=
                   Cairo.Create (M.Ground_Surface);

      procedure Draw_Squares;

      ------------------
      -- Draw_Squares --
      ------------------

      procedure Draw_Squares is
         use Chaos.World;
         M : Main_Model_Access renames Local_Main_Model;
      begin
         Cairo.Set_Source_Rgba (Cr, 0.5, 0.5, 0.5, 0.8);

         for Y in 1 .. M.Squares_Across loop
            for X in 1 .. M.Squares_Across loop
               declare
                  WX  : constant World_Coordinate :=
                          World_Coordinate (X)
                          - M.Squares_Across / 2
                          + M.Left_X - 1;
                  WY  : constant World_Coordinate :=
                          World_Coordinate (Y)
                          - M.Squares_Down / 2
                          + M.Top_Y - 1;
--                    Alt : constant Chaos.Sectors.Altitude_Range :=
--                            Chaos.World.Altitude (WX, WY);
                  Quad : constant Quadrangle := Get_Square_Boundary (WX, WY);
               begin
                  Cairo.Move_To (Cr, Quad (Quad'Last).X, Quad (Quad'Last).Y);
                  for P of Quad loop
                     Cairo.Line_To (Cr, P.X, P.Y);
                  end loop;

                  if X = M.Squares_Across / 2
                    and then Y = M.Squares_Down / 2
                  then
                     declare
                        P : constant Point :=
                              Get_Square_Centre (WX, WY);
                     begin
                        Ada.Text_IO.Put_Line
                          ("centre: "
                           & WX'Img & WY'Img
                           & Integer'Image (Integer (P.X))
                           & Integer'Image (Integer (P.Y)));
                     end;
                  end if;

                  Set_Square_Background (Cr, WX, WY);

                  Cairo.Fill_Preserve (Cr);
                  Cairo.Set_Source_Rgba (Cr, 0.5, 0.5, 0.5, 0.8);
                  Cairo.Stroke (Cr);

--                    Cairo.Move_To (Cr, X1, Y1 + Gdouble (M.Zoom));
--                    Cairo.Set_Source_Rgb (Cr, 1.0, 1.0, 1.0);
--                    Cairo.Show_Text
--                      (Cr, Integer'Image (Integer (Alt)));

               end;
            end loop;
         end loop;
      end Draw_Squares;

   begin

      Cairo.Set_Source_Rgb (Cr, 1.0, 1.0, 1.0);
      Cairo.Paint (Cr);

--        Cairo.Translate (Cr, Gdouble (Width) / 2.0, -Gdouble (Height));
--        Cairo.Rotate (Cr, 68.0 * Ada.Numerics.Pi / 180.0);
      Draw_Squares;

      Cairo.Destroy (Cr);
   end Draw_Model;

   -------------------------
   -- Get_Square_Boundary --
   -------------------------

   function Get_Square_Boundary
     (World_X, World_Y : Chaos.World.World_Coordinate)
      return Quadrangle
   is
      use type Chaos.World.World_Coordinate;
      use type Glib.Gdouble;
      Centre : constant Point := Get_Square_Centre (World_X, World_Y);
      DX     : constant Glib.Gdouble :=
                 Glib.Gdouble (Local_Main_Model.Zoom) / 2.0;
      DY     : constant Glib.Gdouble :=
                 Glib.Gdouble (Local_Main_Model.Zoom) / 2.0;
   begin
      return (1 => (Centre.X - DX, Centre.Y),
              2 => (Centre.X, Centre.Y - DY),
              3 => (Centre.X + DX, Centre.Y),
              4 => (Centre.X, Centre.Y + DY));
   end Get_Square_Boundary;

   -----------------------
   -- Get_Square_Centre --
   -----------------------

   function Get_Square_Centre
     (World_X, World_Y : Chaos.World.World_Coordinate)
      return Point
   is
      use type Glib.Gdouble;
      use Chaos.World;
      M : Main_Model_Access renames Local_Main_Model;
      Centre_X : constant World_Coordinate :=
                   World_X - M.Centre.X;
      Centre_Y : constant World_Coordinate :=
                   World_Y - M.Centre.Y;
      X : constant Glib.Gdouble :=
            Glib.Gdouble (Centre_X - Centre_Y) / 2.0;
      Y : constant Glib.Gdouble :=
            Glib.Gdouble (Centre_X + Centre_Y) / 2.0;
   begin
      return (X * Glib.Gdouble (M.Zoom) + M.Width / 2.0,
              Y * Glib.Gdouble (M.Zoom) + M.Height / 2.0);
   end Get_Square_Centre;

   -------------------------
   -- Get_Square_Top_Left --
   -------------------------

   function Get_Square_Top_Left
     (World_X, World_Y : Chaos.World.World_Coordinate)
      return Point
   is
      use Chaos.World;
      use Glib;
      M : Main_Model_Access renames Local_Main_Model;
      Rel_X : constant World_Coordinate :=
                World_X - M.Left_X + M.Squares_Across / 2;
      Rel_Y : constant World_Coordinate :=
                World_Y - M.Top_Y + M.Squares_Down / 2;
      --  Height : constant World_Coordinate := M.Bottom_Y - M.Top_Y + 1;
      Alt   : constant Chaos.World.Altitude_Range :=
                 Chaos.World.Map.Altitude (World_X, World_Y);
      --  pragma Unreferenced (Alt);

      X     : constant Gdouble :=
                Gdouble (M.Zoom) * Gdouble (Rel_X);
      Y      : constant Gdouble :=
                 Gdouble (M.Zoom) * Gdouble (Rel_Y) - Gdouble (Alt) / 50.0;
   begin
      return (X, Y);
   end Get_Square_Top_Left;

   ----------------------
   -- Get_World_Square --
   ----------------------

   function Get_World_Square
     (P : Point)
      return Chaos.World.World_Location
   is
      M  : Main_Model_Access renames Local_Main_Model;
      Cr : constant Cairo.Cairo_Context :=
             Cairo.Create (M.Ground_Surface);
      Perspective : aliased Cairo.Cairo_Matrix;
--        TX : constant Gdouble :=
--                        Gdouble (M.Squares_Across) * Gdouble (M.Zoom)
--                      * Translate_X;
--        TY          : constant Gdouble :=
--                        Gdouble (M.Squares_Down) * Gdouble (M.Zoom)
--                      * Translate_Y;
      Map_X       : aliased Glib.Gdouble :=
                      P.X;
      Map_Y       : aliased Glib.Gdouble :=
                      P.Y;
   begin
      Cairo.Matrix.Init
        (Perspective'Access,
         Scale_X, Rotate_Y,
         Rotate_X, Scale_Y,
         0.0, 0.0);
--           -TX, -TY);
      Cairo.Set_Matrix
        (Cr, Perspective'Access);
      Cairo.Device_To_User
        (Cr, Map_X'Access, Map_Y'Access);
      Cairo.Destroy (Cr);

      Map_X := Map_X + 70.0;
      Map_Y := Map_Y - 50.0;

      declare
         use Chaos.World;
         Result : constant World_Location :=
                    Chaos.World.Map.Ground
                      (M.Left_X
                       + World_Coordinate (Map_X / Glib.Gdouble (M.Zoom)),
                       M.Top_Y
                       + World_Coordinate (Map_Y / Glib.Gdouble (M.Zoom)));
         Centre : constant Point :=
                    Get_Square_Centre (Result.X, Result.Y);
      begin
         if False then
            Ada.Text_IO.Put_Line
              ("Error: "
               & Integer'Image (Integer (Centre.X - P.X))
               & ", "
               & Integer'Image (Integer (Centre.Y - P.Y))
               & "; size ="
               & Integer'Image (Integer (M.Width))
               & Integer'Image (Integer (M.Height))
               & "; mouse ="
               & Integer'Image (Integer (P.X))
               & Integer'Image (Integer (P.Y))
               & "; altitude ="
               & Altitude_Range'Image (Result.Altitude));
         end if;
         return Result;
      end;
   end Get_World_Square;

   --------------------
   -- Load_Creatures --
   --------------------

--     procedure Load_Creatures is
--     begin
--        Local_Main_Model.Creature_List.Clear;
--        for Creature of Chaos.Db.Creature.Select_By_Top_Record loop
--           if Creature.Hp > 0 then
--              Local_Main_Model.Creature_List.Append (Creature.Reference);
--           end if;
--        end loop;
--        Initiative_Sorting.Sort (Local_Main_Model.Creature_List);
--     end Load_Creatures;

   ---------
   -- Log --
   ---------

   overriding procedure Log
     (Logger : Text_Buffer_Logger;
      Actor  : String;
      Message : String)
   is
      Iter : Gtk.Text_Iter.Gtk_Text_Iter;
   begin
      Logger.Buffer.Get_End_Iter (Iter);
      Logger.Buffer.Insert
        (Iter, Actor & ": " & Message & Character'Val (10));
      declare
         Mark : constant Gtk.Text_Mark.Gtk_Text_Mark :=
                  Logger.Buffer.Get_Mark ("insert");
      begin
         Logger.View.Scroll_Mark_Onscreen (Mark);
      end;

--        Logger.Buffer.Get_End_Iter (Iter);
--        declare
--           Success : constant Boolean :=
--                       Logger.View.Scroll_To_Iter
--                         (Iter          => Iter,
--                          Within_Margin => 0.0,
--                          Use_Align     => False,
--                          Xalign        => 0.0,
--                          Yalign        => 0.0);
--        begin
--           pragma Unreferenced (Success);
--        end;

   end Log;

   -----------
   -- Model --
   -----------

   function Model return Gtk_UI_Model is
   begin
      if Local_Main_Model = null then
         Create_Model;
      end if;

      declare
         use Chaos.World;
         Protagonist : constant Chaos.Db.Creature.Creature_Type :=
                         Chaos.Db.Creature.Get_By_Player
                           (True);
      begin
         Local_Main_Model.Centre :=
           Chaos.World.Map.Ground (World_Coordinate (Protagonist.X),
                                   World_Coordinate (Protagonist.Y));
         Local_Main_Model.Selected_Square := Local_Main_Model.Centre;
         Local_Main_Model.Hover_Square := Local_Main_Model.Selected_Square;
      end;

      Set_Logger
        (new Text_Buffer_Logger'
           (Buffer => Local_Main_Model.Feedback_Text_View.Get_Buffer,
            View   => Local_Main_Model.Feedback_Text_View));

      Local_Main_Model.Timeout_Id :=
        Glib.Main.Timeout_Add (200, On_Timeout'Access);

      return Gtk_UI_Model (Local_Main_Model);
   end Model;

   ----------------------
   -- Motion_Draw_Area --
   ----------------------

   function Motion_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Event : Gdk.Event.Gdk_Event_Motion)
      return Boolean
   is
      pragma Unreferenced (Self);
   begin
      Local_Main_Model.Hover_Square :=
        Get_World_Square ((Event.X, Event.Y));
      Draw_Feedback;
      Local_Main_Model.Draw_Area.Queue_Draw;
      return False;
   end Motion_Draw_Area;

   -----------------------------
   -- On_Command_Button_Click --
   -----------------------------

   procedure On_Command_Button_Click
     (Command_Button : access Gtk.Button.Gtk_Button_Record'Class)
   is
      use type Chaos.Players.Command_Type;
      Button : constant Command_Button_Access :=
                 Command_Button_Access (Command_Button);
      Command : constant Chaos.Players.Command_Type := Button.Command;
   begin
      if not Command.Has_Destination then
         Command.Execute;
      else
         if Command = Local_Main_Model.Current_Command  then
            Local_Main_Model.Current_Command := null;
         else
            Local_Main_Model.Current_Command := Command;
         end if;
      end if;

      Update_Command_Buttons;
      Draw_Feedback;
      Local_Main_Model.Draw_Area.Queue_Draw;

   end On_Command_Button_Click;

   -----------------------
   -- On_Creature_Death --
   -----------------------

   overriding procedure On_Creature_Death
     (Model    : Root_Main_Model;
      Creature : Chaos.Db.Creature_Reference)
   is
      pragma Unreferenced (Model);
      use List_Of_Creatures;
      Position : Cursor :=
                   Local_Main_Model.Creature_List.Find
                     (Creature);
   begin
      pragma Assert (Has_Element (Position));
      Local_Main_Model.Creature_List.Delete (Position);
      Draw_Creatures;
      Local_Main_Model.Draw_Area.Queue_Draw;
   end On_Creature_Death;

   ----------------
   -- On_Timeout --
   ----------------

   function On_Timeout return Boolean is
      use Chaos.Db;
      use type Chaos.Players.Player_Type;
      M : Main_Model_Access renames Local_Main_Model;
   begin
      Chaos.World.Updates.Tick;
      if M.Walking_Creature /= Null_Creature_Reference then
         M.Walking_Path_Index := M.Walking_Path_Index + 1;
         Chaos.Creatures.Set_Location
           (M.Walking_Creature,
            M.Walking_Path (M.Walking_Path_Index));
         Draw_Creatures;
         M.Draw_Area.Queue_Draw;
         if M.Walking_Path_Index = M.Walking_Path'Last then
            M.Walking_Path := null;
            M.Walking_Creature := Null_Creature_Reference;
            M.Walking_Path_Index := 0;
         end if;
      elsif M.Selected_Player /= null then
         null;
      elsif not List_Of_Creatures.Has_Element (M.Acting_Creature) then
         for Creature of M.Creature_List loop
            Chaos.Creatures.Start_Turn (Creature);
         end loop;
         M.Acting_Creature := M.Creature_List.First;
      else
         declare
            use type Chaos.Players.Player_Type;
            Creature : constant Chaos.Db.Creature_Reference :=
                         List_Of_Creatures.Element (M.Acting_Creature);
            Player   : constant Chaos.Players.Player_Type :=
                         Chaos.Players.Get_Party_Member
                           (Creature);
         begin
            if Player /= null then
               if M.Selected_Player /= Player then
                  M.Selected_Player := Player;
                  Show_Tool_Buttons;
               end if;
            else
               declare
                  Finished : Boolean;
               begin
                  Chaos.Creatures.Update.Act (Creature, Finished);
                  if Finished then
                     List_Of_Creatures.Next (M.Acting_Creature);
                  end if;
               end;
            end if;
         end;
      end if;

      return True;
   end On_Timeout;

   ---------------------
   -- Paint_Draw_Area --
   ---------------------

   function Paint_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Cr   : Cairo.Cairo_Context)
      return Boolean
   is
      pragma Unreferenced (Self);
      use Glib;
      M : Main_Model_Access renames Local_Main_Model;
      Perspective : aliased Cairo.Cairo_Matrix;
      TX : constant Gdouble :=
                      Gdouble (M.Squares_Across) * Gdouble (M.Zoom)
                    * Translate_X;
      TY          : constant Gdouble :=
                      Gdouble (M.Squares_Down) * Gdouble (M.Zoom)
                    * Translate_Y;

   begin

      Cairo.Save (Cr);
      if False then
         Cairo.Matrix.Init
           (Perspective'Access,
            Scale_X, Rotate_Y,
            Rotate_X, Scale_Y,
            -TX, -TY);
         Cairo.Set_Matrix
           (Cr, Perspective'Access);
      end if;

      Cairo.Set_Source_Surface
        (Cr, Local_Main_Model.Ground_Surface, 0.0, 0.0);
      Cairo.Paint (Cr);
      Cairo.Set_Source_Surface
        (Cr, Local_Main_Model.Feedback_Surface, 0.0, 0.0);
      Cairo.Paint (Cr);
      Cairo.Set_Source_Surface
        (Cr, Local_Main_Model.Creature_Surface, 0.0, 0.0);
      Cairo.Paint (Cr);
      Cairo.Restore (Cr);

      Cairo.Set_Source_Surface
        (Cr, Local_Main_Model.Interface_Surface, 0.0, 0.0);
      Cairo.Paint (Cr);

      return False;
   end Paint_Draw_Area;

   ------------
   -- Redraw --
   ------------

   procedure Redraw is
      M : Main_Model_Access renames Local_Main_Model;
   begin

      declare
         use Chaos.World;
         Squares_Across : constant World_Coordinate :=
                            World_Coordinate
                              (Natural (M.Width + M.Height) / M.Zoom + 1);
         Squares_Down : constant World_Coordinate :=
                            World_Coordinate
                              (Natural (M.Height + M.Width) / M.Zoom + 1);
      begin
         Local_Main_Model.Left_X :=
           Local_Main_Model.Centre.X - Squares_Across / 2 + 1;
         Local_Main_Model.Right_X :=
           Local_Main_Model.Centre.X + Squares_Across / 2 + 1;
         Local_Main_Model.Top_Y :=
           Local_Main_Model.Centre.Y - Squares_Down / 2 + 1;
         Local_Main_Model.Bottom_Y :=
           Local_Main_Model.Centre.Y + Squares_Down / 2 + 1;
         Local_Main_Model.Squares_Across := Squares_Across;
         Local_Main_Model.Squares_Down := Squares_Down;

         Ada.Text_IO.Put_Line ("Squares across:" & Squares_Across'Img);
         Ada.Text_IO.Put_Line ("Squares down  :" & Squares_Down'Img);
         Ada.Text_IO.Put_Line ("X l/c/r       :"
                               & M.Left_X'Img & M.Centre.X'Img
                                 & M.Right_X'Img);
         Ada.Text_IO.Put_Line ("Y t/c/b       :"
                               & M.Top_Y'Img & M.Centre.Y'Img
                                 & M.Bottom_Y'Img);
      end;

      Draw_Model;
      Draw_Creatures;
      Draw_Feedback;
      Draw_Interface;

   end Redraw;

   ---------------------
   -- Remove_Creature --
   ---------------------

   procedure Remove_Creature
     (Model : in out Root_Main_Model'Class;
      Creature : Chaos.Db.Creature.Creature_Type)
   is
      Position : List_Of_Creatures.Cursor :=
                   Model.Creature_List.Find (Creature.Reference);
      pragma Assert (List_Of_Creatures.Has_Element (Position));
   begin
      Model.Creature_List.Delete (Position);
   end Remove_Creature;

   ----------------------
   -- Scroll_Draw_Area --
   ----------------------

   function Scroll_Draw_Area
     (Self  : access Gtk.Widget.Gtk_Widget_Record'Class;
      Event : Gdk.Event.Gdk_Event_Scroll)
      return Boolean
   is
      M      : Main_Model_Access renames Local_Main_Model;
      Update : Boolean := False;
   begin
      case Event.Direction is
         when Gdk.Event.Scroll_Down =>
            if M.Zoom > 2 then
               M.Zoom := M.Zoom / 2;
               Update := True;
            end if;
         when Gdk.Event.Scroll_Up =>
            if M.Zoom < 256 then
               M.Zoom := M.Zoom * 2;
               Update := True;
            end if;
         when others =>
            null;
      end case;

      if Update then
         Redraw;
         Self.Queue_Draw;
      end if;

      return True;

   end Scroll_Draw_Area;

   ---------------------------
   -- Set_Square_Background --
   ---------------------------

   procedure Set_Square_Background
     (Cr               : Cairo.Cairo_Context;
      World_X, World_Y : Chaos.World.World_Coordinate)
   is
      use Glib;
      Alt : constant Gdouble :=
              Gdouble
                (Chaos.World.Map.Altitude (World_X, World_Y));
   begin
      if Alt < 0.0 then
         Cairo.Set_Source_Rgb (Cr, 0.0, 0.0, 1.0 + Alt / 200.0);
      else
         Cairo.Set_Source_Rgb
           (Cr, Alt / 3800.0, Alt / 7200.0 + 0.5, Alt / 3800.0);
      end if;

   end Set_Square_Background;

   -----------------------
   -- Show_Tool_Buttons --
   -----------------------

   procedure Show_Tool_Buttons is
      use type Gtk.Widget.Gtk_Widget;
      M : Main_Model_Access renames Local_Main_Model;
      Commands : constant Chaos.Players.Player_Commands :=
                   M.Selected_Player.Commands;
   begin
      while M.Tool_Button_Box.Get_Child (0) /= null loop
         M.Tool_Button_Box.Remove (M.Tool_Button_Box.Get_Child (0));
      end loop;
      for Item of Commands loop
         declare
--              Button : constant Gtk.Button.Gtk_Button :=
--                         Gtk.Button.Gtk_Button_New_With_Label
--                           (Chaos.UI.Localisation.Local_Capital_Text
--                              (Item.Tag & "-button"));
         begin
            M.Tool_Button_Box.Add
              (Create_Command_Button (Item));
         end;
      end loop;
      M.Tool_Button_Box.Show_All;

   end Show_Tool_Buttons;

   ----------------------------
   -- Update_Command_Buttons --
   ----------------------------

   procedure Update_Command_Buttons is
      use Glib;
      M : Main_Model_Access renames Local_Main_Model;
      Index : Gint := 0;
   begin
      loop
         declare
            Child : constant Command_Button_Access :=
                      Command_Button_Access
                        (M.Tool_Button_Box.Get_Child (Index));
         begin
            exit when Child = null;
            Child.Set_Sensitive (Child.Command.Available);
         end;
         Index := Index + 1;
      end loop;
   end Update_Command_Buttons;

end Chaos.UI.Gtk_UI.Main_Model;
